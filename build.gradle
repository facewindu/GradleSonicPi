import com.google.common.base.Joiner
import com.illposed.osc.OSCMessage
import com.illposed.osc.OSCMessageEvent
import com.illposed.osc.messageselector.OSCPatternAddressMessageSelector
import com.illposed.osc.transport.udp.OSCPortIn
import com.illposed.osc.transport.udp.OSCPortOut
import org.gradle.api.services.BuildService
import org.gradle.api.services.BuildServiceParameters

import java.util.concurrent.Semaphore

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.illposed.osc:javaosc-core:0.7'
        classpath 'com.google.guava:guava:30.0-jre'
        classpath 'javax.inject:javax.inject:1'
    }
}

abstract class SonicPiBuildService implements BuildService<Parameters>, AutoCloseable {
    final SonicPiChannel sonicPi
    interface Parameters extends BuildServiceParameters {
        Property<String> getProjectName()
    }

    SonicPiBuildService() {
        sonicPi = new SonicPiChannel(parameters.projectName.get())
    }

    @Override
    void close() {
        sonicPi.close()
    }
}

class SonicPiChannel {

    private static final int DEFAULT_SONIC_PI_OSC_PORT = 4560
    private static final int DEFAULT_OSC_PORT_IN = 57110
    private final Semaphore semaphore = new Semaphore(1, true)
    private final OSCPortOut sonicPiSender = new OSCPortOut(new InetSocketAddress(DEFAULT_SONIC_PI_OSC_PORT))
    private final OSCPortIn sonicPiReceiver = new OSCPortIn(DEFAULT_OSC_PORT_IN)
    private final String projectName
    private final UUID uuid

    SonicPiChannel(String projectName) {
        println "NEW SonicPiChannel, with a semaphore with ${semaphore.availablePermits()} permits"
        this.uuid = UUID.randomUUID()
        this.projectName = projectName
        sonicPiReceiver.setResilient(true)
        sonicPiReceiver.getDispatcher().setAlwaysDispatchingImmediately(true)
        sonicPiReceiver.getDispatcher().addListener(new OSCPatternAddressMessageSelector('/ack'), this.&onAck)
        sonicPiReceiver.startListening()
        println 'Configured SonicPi receiver: ' + sonicPiReceiver
        println 'Configured SonicPi sender: ' + sonicPiSender
        buildStarted()
    }

    void onAck(OSCMessageEvent ignored) {
        semaphore.release()
    }

    void buildStarted() {
        sendMessage('build', projectName + "_" + uniqueId(), 'started')
    }

    void taskStarted(String taskId) {
        sendMessage('task', taskId + "_" + uniqueId(), 'started')
    }

    void taskFinished(String taskId) {
        sendMessage('task', taskId + "_" + uniqueId(), 'finished')
    }

    void buildFinished() {
        sendMessage('build', projectName + "_" + uniqueId(), 'finished')
        semaphore.drainPermits()
    }

    void sendMessage(String type, String id, String action) {
        try {
            semaphore.acquire()
            def address = '/event/' + Joiner.on('/').join([type, id, action])
            sonicPiSender.send(new OSCMessage(address, []))
        } catch (InterruptedException e) {
            System.err.println('interrupted')
        } catch (Throwable t) {
            System.err.println('Could not send msg')
            t.printStackTrace()
        }
    }

    String uniqueId() {
        uuid.toString()
    }

    void close() {
        println 'build finished'
        buildFinished()
    }

}

def sonicPiBuildServiceProvider = project.gradle.sharedServices.registerIfAbsent('sonicPi', SonicPiBuildService) {
    it.parameters.projectName.set(gradle.rootProject.name)
} as Provider<SonicPiBuildService>
def playTask = tasks.register('play')

def nbTask = 20
nbTask.times {
    def musicTask = tasks.register("music_$it", MusicTask)
    playTask.configure {
        it.dependsOn musicTask
    }
}


gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {
    @Override
    void beforeExecute(Task task) {
        sonicPiBuildServiceProvider.get().sonicPi.taskStarted(task.path)
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        sonicPiBuildServiceProvider.get().sonicPi.taskFinished(task.path)
    }
})

abstract class MusicTask extends DefaultTask {

    @javax.inject.Inject
    abstract WorkerExecutor getWorkerExecutor()

    @TaskAction
    void doStuff() {
        workerExecutor.noIsolation().submit(MusicTaskAction) {}
    }
}

interface MusicTaskParameters extends WorkParameters {
}

abstract class MusicTaskAction implements WorkAction<MusicTaskParameters> {

    def random = new Random()
    
    @Override
    void execute() {
        sleep random.nextInt(500)
    }
}

